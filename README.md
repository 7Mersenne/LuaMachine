# LuaMachine

Unreal Engine 4 Plugin for adding Lua scripting to your projects.

If you want modders to customize your game/project, or you need to allow game designers to script parts of the logic, this plugin is for you.

## How it works

Contrary to the other Unreal Engine 4 Lua plugins, this one does not try to expose the Unreal Engine 4 api, but completely hides it exposing to the user/scripter only the features the developer decided to include (via Blueprints or C++).

## Quickstart

In this fast (and useless example) we will print a string generated by a Lua script.

Open your favourite editor for lua scripting and create a file into the project Content/ directory (call it hello.lua) with the following code:

```lua
current_time = os.date()
return "Hello, i am a lua script, current time is: " .. current_time
```

Now you need to create a new LuaState, it is a special Blueprint representing a Lua Virtual Machine (you can have multple Lua virtual machines in the same project). Just add a new blueprint inheriting from LuaState and name as you want (QuickLuaState is a good candidate).

Finally open your Level Blueprint and add the following nodes:

![Quickstart](Docs/Screenshots/Quickstart.PNG?raw=true "Quickstart")

If you play the game, you will see the Lua string printed on top.

The LuaRunFile node will execute a lua file (relative to the Content/ directory) in the specified LuaState (QuickLuaState in our case) and will return the value returned by the script itself as a LuaValue UStruct. The plugin offers a bunch of operations you can apply to LuaValue's, in this example we simply converted the value to an Unreal String.

Time to something more complex, edit your hello.lua script:

```lua

function call_me_from_unreal(number)
  return number * 2
end

current_time = os.date()
return "Hello, i am a lua script, current time is: " .. current_time
```

Now the script will add the call_me_from_unreal function to the global table:

![Quickstart2](Docs/Screenshots/Quickstart2.PNG?raw=true "Quickstart2")

The LuaGlobalCall node calls a function from the global table passing arguments as an array of LuaValue's.

So, now we know how to call lua functions from Unreal, time to do the opposite.

Open the QuickLuaState Blueprint you created before. This Blueprint exposes lot of different fields to configure your Lua Virtual Machine:

![Quickstart3](Docs/Screenshots/Quickstart3.PNG?raw=true "Quickstart3")

The Table 'TMap' allows you to add items to the Lua global table. We will first try by adding a string and a number (float):

![Quickstart4](Docs/Screenshots/Quickstart4.PNG?raw=true "Quickstart4")

Note that we set the "Lua Filename" field to hello.lua, in this way we can avoid to call the LuaRunFile node as hello.lua will be executed during the spawn of the QuickLuaState.

Let's modify our Level Blueprint:

![Quickstart5](Docs/Screenshots/Quickstart5.PNG?raw=true "Quickstart5")

The hello.lua script is loaded automatically, while the LuaGetGlobal nodes, retrieve the specific fields from the Lua global table, and return them as LuaValue's

Time to expose an Unreal UFunction to Lua: just add a Function to QuickLuaState:

![Quickstart6](Docs/Screenshots/Quickstart6.PNG?raw=true "Quickstart6")

and expose it in the Table TMap:

![Quickstart7](Docs/Screenshots/Quickstart7.PNG?raw=true "Quickstart7")

calling get_player_location() from lua, will trigger the QuickLuaState's GetPlayerPawnLocation(). Note that not all of the UFunction's can be exposed: if they take or return values they must be LuaValue's

Let's update hello.lua

```lua
function call_me_from_unreal(number)
    location = get_player_location()
    print(location.x, location.y, location.z)
    return number * 2 + location.x + location.y + location.z
end

current_time = os.date()
return "Hello, i am a lua script, current time is: " .. current_time
```

and the Level Blueprint:

![Quickstart8](Docs/Screenshots/Quickstart8.PNG?raw=true "Quickstart8")

Please check the print() function: it is automatically mapped to the Unreal Output Log by the plugin.

Now you should have an idea of the plugin potential, continue reading for more infos.

## LuaState

A LuaState (ULuaState C++ class) represents a single Lua virtual machine (there can be multiple, each one isolated from the others). This is a "singleton" as each LuaState class can have a single instance for the whole process life. (Note that while in the Editor, LuaState's are constantly recreated whenever you enter PIE mode to simplify development)

Having multiple LuaState's allows clean separation of domains: as an example you may want a state for game configuration, another one for game logic and one for the modders. More complex examples include having states dedicated to specific Actors, GameModes or Levels.

LuaState's are loaded on-demand, so you can create dozens of them but they will not start Lua VMs until you do not need them.

LuaState's can load and execute scripts automatically if you specify the field "LuaCodeAsset" and/or "LuaFilename". You can load scripts (both in text and bytecode format) from your filesystem (via "LuaFilename"), or from a specific asset exposed by the plugin, named LuaCode (you can specify it with the "LuaCodeAsset" field). The advantage of using filesystem scripts is that you can change them even after the project has been packaged (unless yo package them too), while LuaCode assets are directly built in your pak files (as bytecode by default).


## LuaValue

LuaValue's are the way Unreal communicates with a specific Lua virtual machine. They contains values that both Lua and your project can use.

This a list of the currently supported values:

* Nil (nil/NULL value)
* Bool (boolean value)
* Integer (integer/int32 value)
* Number (float value)
* String (string/FString value)
* Function (reference to a lua function)
* Table (reference to a lua table)
* UObject (reference to an Unreal UObject)
* UFunction (reference to an Unreal UFunction)

## Calling Lua functions

## Exposing UFunctions

## LuaComponent



## Functional Tests

## Commercial Support

## Sponsors







